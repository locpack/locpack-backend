// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package service

import (
	"locpack-backend/internal/service/model"

	mock "github.com/stretchr/testify/mock"
)

// NewMockPlaceService creates a new instance of MockPlaceService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPlaceService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPlaceService {
	mock := &MockPlaceService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPlaceService is an autogenerated mock type for the PlaceService type
type MockPlaceService struct {
	mock.Mock
}

type MockPlaceService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPlaceService) EXPECT() *MockPlaceService_Expecter {
	return &MockPlaceService_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockPlaceService
func (_mock *MockPlaceService) Create(userID string, pc model.PlaceCreate) (model.Place, error) {
	ret := _mock.Called(userID, pc)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 model.Place
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, model.PlaceCreate) (model.Place, error)); ok {
		return returnFunc(userID, pc)
	}
	if returnFunc, ok := ret.Get(0).(func(string, model.PlaceCreate) model.Place); ok {
		r0 = returnFunc(userID, pc)
	} else {
		r0 = ret.Get(0).(model.Place)
	}
	if returnFunc, ok := ret.Get(1).(func(string, model.PlaceCreate) error); ok {
		r1 = returnFunc(userID, pc)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPlaceService_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockPlaceService_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - userID
//   - pc
func (_e *MockPlaceService_Expecter) Create(userID interface{}, pc interface{}) *MockPlaceService_Create_Call {
	return &MockPlaceService_Create_Call{Call: _e.mock.On("Create", userID, pc)}
}

func (_c *MockPlaceService_Create_Call) Run(run func(userID string, pc model.PlaceCreate)) *MockPlaceService_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(model.PlaceCreate))
	})
	return _c
}

func (_c *MockPlaceService_Create_Call) Return(place model.Place, err error) *MockPlaceService_Create_Call {
	_c.Call.Return(place, err)
	return _c
}

func (_c *MockPlaceService_Create_Call) RunAndReturn(run func(userID string, pc model.PlaceCreate) (model.Place, error)) *MockPlaceService_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockPlaceService
func (_mock *MockPlaceService) GetByID(placeID string, userID string) (model.Place, error) {
	ret := _mock.Called(placeID, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 model.Place
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) (model.Place, error)); ok {
		return returnFunc(placeID, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) model.Place); ok {
		r0 = returnFunc(placeID, userID)
	} else {
		r0 = ret.Get(0).(model.Place)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(placeID, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPlaceService_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockPlaceService_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - placeID
//   - userID
func (_e *MockPlaceService_Expecter) GetByID(placeID interface{}, userID interface{}) *MockPlaceService_GetByID_Call {
	return &MockPlaceService_GetByID_Call{Call: _e.mock.On("GetByID", placeID, userID)}
}

func (_c *MockPlaceService_GetByID_Call) Run(run func(placeID string, userID string)) *MockPlaceService_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockPlaceService_GetByID_Call) Return(place model.Place, err error) *MockPlaceService_GetByID_Call {
	_c.Call.Return(place, err)
	return _c
}

func (_c *MockPlaceService_GetByID_Call) RunAndReturn(run func(placeID string, userID string) (model.Place, error)) *MockPlaceService_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByNameOrAddress provides a mock function for the type MockPlaceService
func (_mock *MockPlaceService) GetByNameOrAddress(query string, userID string) ([]model.Place, error) {
	ret := _mock.Called(query, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByNameOrAddress")
	}

	var r0 []model.Place
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) ([]model.Place, error)); ok {
		return returnFunc(query, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) []model.Place); ok {
		r0 = returnFunc(query, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Place)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(query, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPlaceService_GetByNameOrAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByNameOrAddress'
type MockPlaceService_GetByNameOrAddress_Call struct {
	*mock.Call
}

// GetByNameOrAddress is a helper method to define mock.On call
//   - query
//   - userID
func (_e *MockPlaceService_Expecter) GetByNameOrAddress(query interface{}, userID interface{}) *MockPlaceService_GetByNameOrAddress_Call {
	return &MockPlaceService_GetByNameOrAddress_Call{Call: _e.mock.On("GetByNameOrAddress", query, userID)}
}

func (_c *MockPlaceService_GetByNameOrAddress_Call) Run(run func(query string, userID string)) *MockPlaceService_GetByNameOrAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockPlaceService_GetByNameOrAddress_Call) Return(places []model.Place, err error) *MockPlaceService_GetByNameOrAddress_Call {
	_c.Call.Return(places, err)
	return _c
}

func (_c *MockPlaceService_GetByNameOrAddress_Call) RunAndReturn(run func(query string, userID string) ([]model.Place, error)) *MockPlaceService_GetByNameOrAddress_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateByID provides a mock function for the type MockPlaceService
func (_mock *MockPlaceService) UpdateByID(placeID string, userID string, pu model.PlaceUpdate) (model.Place, error) {
	ret := _mock.Called(placeID, userID, pu)

	if len(ret) == 0 {
		panic("no return value specified for UpdateByID")
	}

	var r0 model.Place
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string, model.PlaceUpdate) (model.Place, error)); ok {
		return returnFunc(placeID, userID, pu)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string, model.PlaceUpdate) model.Place); ok {
		r0 = returnFunc(placeID, userID, pu)
	} else {
		r0 = ret.Get(0).(model.Place)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string, model.PlaceUpdate) error); ok {
		r1 = returnFunc(placeID, userID, pu)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPlaceService_UpdateByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateByID'
type MockPlaceService_UpdateByID_Call struct {
	*mock.Call
}

// UpdateByID is a helper method to define mock.On call
//   - placeID
//   - userID
//   - pu
func (_e *MockPlaceService_Expecter) UpdateByID(placeID interface{}, userID interface{}, pu interface{}) *MockPlaceService_UpdateByID_Call {
	return &MockPlaceService_UpdateByID_Call{Call: _e.mock.On("UpdateByID", placeID, userID, pu)}
}

func (_c *MockPlaceService_UpdateByID_Call) Run(run func(placeID string, userID string, pu model.PlaceUpdate)) *MockPlaceService_UpdateByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(model.PlaceUpdate))
	})
	return _c
}

func (_c *MockPlaceService_UpdateByID_Call) Return(place model.Place, err error) *MockPlaceService_UpdateByID_Call {
	_c.Call.Return(place, err)
	return _c
}

func (_c *MockPlaceService_UpdateByID_Call) RunAndReturn(run func(placeID string, userID string, pu model.PlaceUpdate) (model.Place, error)) *MockPlaceService_UpdateByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPackService creates a new instance of MockPackService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPackService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPackService {
	mock := &MockPackService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPackService is an autogenerated mock type for the PackService type
type MockPackService struct {
	mock.Mock
}

type MockPackService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPackService) EXPECT() *MockPackService_Expecter {
	return &MockPackService_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockPackService
func (_mock *MockPackService) Create(userID string, pc model.PackCreate) (model.Pack, error) {
	ret := _mock.Called(userID, pc)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 model.Pack
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, model.PackCreate) (model.Pack, error)); ok {
		return returnFunc(userID, pc)
	}
	if returnFunc, ok := ret.Get(0).(func(string, model.PackCreate) model.Pack); ok {
		r0 = returnFunc(userID, pc)
	} else {
		r0 = ret.Get(0).(model.Pack)
	}
	if returnFunc, ok := ret.Get(1).(func(string, model.PackCreate) error); ok {
		r1 = returnFunc(userID, pc)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackService_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockPackService_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - userID
//   - pc
func (_e *MockPackService_Expecter) Create(userID interface{}, pc interface{}) *MockPackService_Create_Call {
	return &MockPackService_Create_Call{Call: _e.mock.On("Create", userID, pc)}
}

func (_c *MockPackService_Create_Call) Run(run func(userID string, pc model.PackCreate)) *MockPackService_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(model.PackCreate))
	})
	return _c
}

func (_c *MockPackService_Create_Call) Return(pack model.Pack, err error) *MockPackService_Create_Call {
	_c.Call.Return(pack, err)
	return _c
}

func (_c *MockPackService_Create_Call) RunAndReturn(run func(userID string, pc model.PackCreate) (model.Pack, error)) *MockPackService_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockPackService
func (_mock *MockPackService) GetByID(packID string, userID string) (model.Pack, error) {
	ret := _mock.Called(packID, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 model.Pack
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) (model.Pack, error)); ok {
		return returnFunc(packID, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) model.Pack); ok {
		r0 = returnFunc(packID, userID)
	} else {
		r0 = ret.Get(0).(model.Pack)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(packID, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackService_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockPackService_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - packID
//   - userID
func (_e *MockPackService_Expecter) GetByID(packID interface{}, userID interface{}) *MockPackService_GetByID_Call {
	return &MockPackService_GetByID_Call{Call: _e.mock.On("GetByID", packID, userID)}
}

func (_c *MockPackService_GetByID_Call) Run(run func(packID string, userID string)) *MockPackService_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockPackService_GetByID_Call) Return(pack model.Pack, err error) *MockPackService_GetByID_Call {
	_c.Call.Return(pack, err)
	return _c
}

func (_c *MockPackService_GetByID_Call) RunAndReturn(run func(packID string, userID string) (model.Pack, error)) *MockPackService_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByNameOrAuthor provides a mock function for the type MockPackService
func (_mock *MockPackService) GetByNameOrAuthor(query string, userID string) ([]model.Pack, error) {
	ret := _mock.Called(query, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByNameOrAuthor")
	}

	var r0 []model.Pack
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) ([]model.Pack, error)); ok {
		return returnFunc(query, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) []model.Pack); ok {
		r0 = returnFunc(query, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Pack)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(query, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackService_GetByNameOrAuthor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByNameOrAuthor'
type MockPackService_GetByNameOrAuthor_Call struct {
	*mock.Call
}

// GetByNameOrAuthor is a helper method to define mock.On call
//   - query
//   - userID
func (_e *MockPackService_Expecter) GetByNameOrAuthor(query interface{}, userID interface{}) *MockPackService_GetByNameOrAuthor_Call {
	return &MockPackService_GetByNameOrAuthor_Call{Call: _e.mock.On("GetByNameOrAuthor", query, userID)}
}

func (_c *MockPackService_GetByNameOrAuthor_Call) Run(run func(query string, userID string)) *MockPackService_GetByNameOrAuthor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockPackService_GetByNameOrAuthor_Call) Return(packs []model.Pack, err error) *MockPackService_GetByNameOrAuthor_Call {
	_c.Call.Return(packs, err)
	return _c
}

func (_c *MockPackService_GetByNameOrAuthor_Call) RunAndReturn(run func(query string, userID string) ([]model.Pack, error)) *MockPackService_GetByNameOrAuthor_Call {
	_c.Call.Return(run)
	return _c
}

// GetCreatedByUserID provides a mock function for the type MockPackService
func (_mock *MockPackService) GetCreatedByUserID(userID string) ([]model.Pack, error) {
	ret := _mock.Called(userID)

	if len(ret) == 0 {
		panic("no return value specified for GetCreatedByUserID")
	}

	var r0 []model.Pack
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) ([]model.Pack, error)); ok {
		return returnFunc(userID)
	}
	if returnFunc, ok := ret.Get(0).(func(string) []model.Pack); ok {
		r0 = returnFunc(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Pack)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackService_GetCreatedByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCreatedByUserID'
type MockPackService_GetCreatedByUserID_Call struct {
	*mock.Call
}

// GetCreatedByUserID is a helper method to define mock.On call
//   - userID
func (_e *MockPackService_Expecter) GetCreatedByUserID(userID interface{}) *MockPackService_GetCreatedByUserID_Call {
	return &MockPackService_GetCreatedByUserID_Call{Call: _e.mock.On("GetCreatedByUserID", userID)}
}

func (_c *MockPackService_GetCreatedByUserID_Call) Run(run func(userID string)) *MockPackService_GetCreatedByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockPackService_GetCreatedByUserID_Call) Return(packs []model.Pack, err error) *MockPackService_GetCreatedByUserID_Call {
	_c.Call.Return(packs, err)
	return _c
}

func (_c *MockPackService_GetCreatedByUserID_Call) RunAndReturn(run func(userID string) ([]model.Pack, error)) *MockPackService_GetCreatedByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// GetFollowedByUserID provides a mock function for the type MockPackService
func (_mock *MockPackService) GetFollowedByUserID(userID string) ([]model.Pack, error) {
	ret := _mock.Called(userID)

	if len(ret) == 0 {
		panic("no return value specified for GetFollowedByUserID")
	}

	var r0 []model.Pack
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) ([]model.Pack, error)); ok {
		return returnFunc(userID)
	}
	if returnFunc, ok := ret.Get(0).(func(string) []model.Pack); ok {
		r0 = returnFunc(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Pack)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackService_GetFollowedByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFollowedByUserID'
type MockPackService_GetFollowedByUserID_Call struct {
	*mock.Call
}

// GetFollowedByUserID is a helper method to define mock.On call
//   - userID
func (_e *MockPackService_Expecter) GetFollowedByUserID(userID interface{}) *MockPackService_GetFollowedByUserID_Call {
	return &MockPackService_GetFollowedByUserID_Call{Call: _e.mock.On("GetFollowedByUserID", userID)}
}

func (_c *MockPackService_GetFollowedByUserID_Call) Run(run func(userID string)) *MockPackService_GetFollowedByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockPackService_GetFollowedByUserID_Call) Return(packs []model.Pack, err error) *MockPackService_GetFollowedByUserID_Call {
	_c.Call.Return(packs, err)
	return _c
}

func (_c *MockPackService_GetFollowedByUserID_Call) RunAndReturn(run func(userID string) ([]model.Pack, error)) *MockPackService_GetFollowedByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// GetPlacesByID provides a mock function for the type MockPackService
func (_mock *MockPackService) GetPlacesByID(packID string, userID string) ([]model.Place, error) {
	ret := _mock.Called(packID, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetPlacesByID")
	}

	var r0 []model.Place
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) ([]model.Place, error)); ok {
		return returnFunc(packID, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) []model.Place); ok {
		r0 = returnFunc(packID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Place)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(packID, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackService_GetPlacesByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPlacesByID'
type MockPackService_GetPlacesByID_Call struct {
	*mock.Call
}

// GetPlacesByID is a helper method to define mock.On call
//   - packID
//   - userID
func (_e *MockPackService_Expecter) GetPlacesByID(packID interface{}, userID interface{}) *MockPackService_GetPlacesByID_Call {
	return &MockPackService_GetPlacesByID_Call{Call: _e.mock.On("GetPlacesByID", packID, userID)}
}

func (_c *MockPackService_GetPlacesByID_Call) Run(run func(packID string, userID string)) *MockPackService_GetPlacesByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockPackService_GetPlacesByID_Call) Return(places []model.Place, err error) *MockPackService_GetPlacesByID_Call {
	_c.Call.Return(places, err)
	return _c
}

func (_c *MockPackService_GetPlacesByID_Call) RunAndReturn(run func(packID string, userID string) ([]model.Place, error)) *MockPackService_GetPlacesByID_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateByID provides a mock function for the type MockPackService
func (_mock *MockPackService) UpdateByID(packID string, userID string, pu model.PackUpdate) (model.Pack, error) {
	ret := _mock.Called(packID, userID, pu)

	if len(ret) == 0 {
		panic("no return value specified for UpdateByID")
	}

	var r0 model.Pack
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string, model.PackUpdate) (model.Pack, error)); ok {
		return returnFunc(packID, userID, pu)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string, model.PackUpdate) model.Pack); ok {
		r0 = returnFunc(packID, userID, pu)
	} else {
		r0 = ret.Get(0).(model.Pack)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string, model.PackUpdate) error); ok {
		r1 = returnFunc(packID, userID, pu)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackService_UpdateByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateByID'
type MockPackService_UpdateByID_Call struct {
	*mock.Call
}

// UpdateByID is a helper method to define mock.On call
//   - packID
//   - userID
//   - pu
func (_e *MockPackService_Expecter) UpdateByID(packID interface{}, userID interface{}, pu interface{}) *MockPackService_UpdateByID_Call {
	return &MockPackService_UpdateByID_Call{Call: _e.mock.On("UpdateByID", packID, userID, pu)}
}

func (_c *MockPackService_UpdateByID_Call) Run(run func(packID string, userID string, pu model.PackUpdate)) *MockPackService_UpdateByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(model.PackUpdate))
	})
	return _c
}

func (_c *MockPackService_UpdateByID_Call) Return(pack model.Pack, err error) *MockPackService_UpdateByID_Call {
	_c.Call.Return(pack, err)
	return _c
}

func (_c *MockPackService_UpdateByID_Call) RunAndReturn(run func(packID string, userID string, pu model.PackUpdate) (model.Pack, error)) *MockPackService_UpdateByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserService creates a new instance of MockUserService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserService {
	mock := &MockUserService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserService is an autogenerated mock type for the UserService type
type MockUserService struct {
	mock.Mock
}

type MockUserService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserService) EXPECT() *MockUserService_Expecter {
	return &MockUserService_Expecter{mock: &_m.Mock}
}

// GetByID provides a mock function for the type MockUserService
func (_mock *MockUserService) GetByID(id string) (model.User, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 model.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (model.User, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(string) model.User); ok {
		r0 = returnFunc(id)
	} else {
		r0 = ret.Get(0).(model.User)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockUserService_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - id
func (_e *MockUserService_Expecter) GetByID(id interface{}) *MockUserService_GetByID_Call {
	return &MockUserService_GetByID_Call{Call: _e.mock.On("GetByID", id)}
}

func (_c *MockUserService_GetByID_Call) Run(run func(id string)) *MockUserService_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockUserService_GetByID_Call) Return(user model.User, err error) *MockUserService_GetByID_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserService_GetByID_Call) RunAndReturn(run func(id string) (model.User, error)) *MockUserService_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateByID provides a mock function for the type MockUserService
func (_mock *MockUserService) UpdateByID(id string, uu model.UserUpdate) (model.User, error) {
	ret := _mock.Called(id, uu)

	if len(ret) == 0 {
		panic("no return value specified for UpdateByID")
	}

	var r0 model.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, model.UserUpdate) (model.User, error)); ok {
		return returnFunc(id, uu)
	}
	if returnFunc, ok := ret.Get(0).(func(string, model.UserUpdate) model.User); ok {
		r0 = returnFunc(id, uu)
	} else {
		r0 = ret.Get(0).(model.User)
	}
	if returnFunc, ok := ret.Get(1).(func(string, model.UserUpdate) error); ok {
		r1 = returnFunc(id, uu)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_UpdateByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateByID'
type MockUserService_UpdateByID_Call struct {
	*mock.Call
}

// UpdateByID is a helper method to define mock.On call
//   - id
//   - uu
func (_e *MockUserService_Expecter) UpdateByID(id interface{}, uu interface{}) *MockUserService_UpdateByID_Call {
	return &MockUserService_UpdateByID_Call{Call: _e.mock.On("UpdateByID", id, uu)}
}

func (_c *MockUserService_UpdateByID_Call) Run(run func(id string, uu model.UserUpdate)) *MockUserService_UpdateByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(model.UserUpdate))
	})
	return _c
}

func (_c *MockUserService_UpdateByID_Call) Return(user model.User, err error) *MockUserService_UpdateByID_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserService_UpdateByID_Call) RunAndReturn(run func(id string, uu model.UserUpdate) (model.User, error)) *MockUserService_UpdateByID_Call {
	_c.Call.Return(run)
	return _c
}
